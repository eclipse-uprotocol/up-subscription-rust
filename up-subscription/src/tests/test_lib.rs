/********************************************************************************
 * Copyright (c) 2024 Contributors to the Eclipse Foundation
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Apache License Version 2.0 which is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * SPDX-License-Identifier: Apache-2.0
 ********************************************************************************/

use up_rust::{communication::CallOptions, UMessage};

// This determines whether two UMessages are equivalent - meaning, whether they have the same
// properties and content EXCEPT for the message IDs.
// This is useful for comparing UMessages in test cases where the ID is random-generated and so cannot usefully be part
// of an assertion-comparison between UMessage objects built for the test case and the UMessage generated by tested code.
pub(crate) fn is_equivalent_umessage(first_message: &UMessage, other_message: &UMessage) -> bool {
    first_message.attributes.commstatus == other_message.attributes.commstatus
        && first_message.attributes.payload_format == other_message.attributes.payload_format
        && first_message.attributes.permission_level == other_message.attributes.permission_level
        && first_message.attributes.priority == other_message.attributes.priority
        && first_message.attributes.reqid == other_message.attributes.reqid
        && first_message.attributes.sink == other_message.attributes.sink
        && first_message.attributes.source == other_message.attributes.source
        && first_message.attributes.special_fields == other_message.attributes.special_fields
        && first_message.attributes.token == other_message.attributes.token
        && first_message.attributes.type_ == other_message.attributes.type_
        && first_message.attributes.ttl == other_message.attributes.ttl
        && first_message.payload == other_message.payload
        && first_message.special_fields == other_message.special_fields
}

// This determines whether two CallOptions are equivalent - meaning, whether they have the same
// properties and content EXCEPT for the message IDs.
// This is useful for comparing CallOptions in test cases where the ID is random-generated and so cannot usefully be part
// of an assertion-comparison between CallOptions objects built for the test case and the CallOptions generated by tested code.
pub(crate) fn is_equivalent_calloptions(
    first_options: &CallOptions,
    other_options: &CallOptions,
) -> bool {
    first_options.priority() == other_options.priority()
        && first_options.token() == other_options.token()
        && first_options.ttl() == other_options.ttl()
}

// This module holds a variety of object mocks and associated helper methods, to be used in tests
#[cfg(test)]
pub(crate) mod mocks {
    use async_trait::async_trait;
    use mockall::mock;
    use std::sync::Arc;
    use tokio::sync::mpsc::{self, Receiver, Sender};

    use up_rust::core::usubscription::{
        FetchSubscribersRequest, FetchSubscribersResponse, FetchSubscriptionsRequest,
        FetchSubscriptionsResponse, NotificationsRequest, SubscriberInfo, SubscriptionRequest,
        SubscriptionResponse, SubscriptionStatus, USubscription, UnsubscribeRequest, Update,
    };
    use up_rust::{
        communication::{CallOptions, RpcClient, ServiceInvocationError, UPayload},
        LocalUriProvider, UListener, UMessage, UStatus, UTransport, UUri,
    };

    use crate::{test_lib, USubscriptionConfiguration};
    use crate::{USubscriptionService, USubscriptionServiceAbstract, UTransportHolder};

    // UTransportMock for testing Notification functionality via implementation of the UTransport::send() method,
    // which mirrors recieved data back to an outside Receiver (which would be the calling test case).
    // This is necessary because with a standard (mockall) mock, the test cases finishes before message-passing and
    // notification business logic (that is running it's own task) reacts and actually does anything.
    pub(crate) type NotificationTuple = (SubscriberInfo, UUri, SubscriptionStatus);

    pub(crate) struct NotificationTransportMock {
        send_sender: Sender<NotificationTuple>,
    }

    impl NotificationTransportMock {
        pub(crate) fn new(send_sender: Sender<NotificationTuple>) -> NotificationTransportMock {
            NotificationTransportMock { send_sender }
        }
    }

    #[async_trait]
    impl UTransport for NotificationTransportMock {
        async fn send(&self, message: UMessage) -> Result<(), UStatus> {
            let update: Update = message.extract_protobuf().unwrap();

            let tuple: (
                up_rust::core::usubscription::SubscriberInfo,
                UUri,
                SubscriptionStatus,
            ) = (
                update.subscriber.unwrap_or_default(),
                update.topic.unwrap_or_default(),
                update.status.unwrap_or_default(),
            );
            self.send_sender
                .send(tuple)
                .await
                .expect("Error sending update properties");

            Ok(())
        }

        async fn receive(
            &self,
            _source_filter: &UUri,
            _sink_filter: Option<&UUri>,
        ) -> Result<UMessage, UStatus> {
            todo!()
        }

        async fn register_listener(
            &self,
            _source_filter: &UUri,
            _sink_filter: Option<&UUri>,
            _listener: Arc<dyn UListener>,
        ) -> Result<(), UStatus> {
            todo!()
        }

        async fn unregister_listener(
            &self,
            _source_filter: &UUri,
            _sink_filter: Option<&UUri>,
            _listener: Arc<dyn UListener>,
        ) -> Result<(), UStatus> {
            todo!()
        }
    }

    // Mocks built using the mockall crate
    mock! {
        pub(crate) Transport {
            async fn do_send(&self, message: UMessage) -> Result<(), UStatus>;
            async fn do_register_listener<'a>(&'a self, source_filter: &'a UUri, sink_filter: Option<&'a UUri>, listener: Arc<dyn UListener>) -> Result<(), UStatus>;
            async fn do_unregister_listener<'a>(&'a self, source_filter: &'a UUri, sink_filter: Option<&'a UUri>, listener: Arc<dyn UListener>) -> Result<(), UStatus>;
        }
    }

    #[async_trait]
    impl UTransport for MockTransport {
        async fn send(&self, message: UMessage) -> Result<(), UStatus> {
            self.do_send(message).await
        }
        async fn register_listener(
            &self,
            source_filter: &UUri,
            sink_filter: Option<&UUri>,
            listener: Arc<dyn UListener>,
        ) -> Result<(), UStatus> {
            self.do_register_listener(source_filter, sink_filter, listener)
                .await
        }
        async fn unregister_listener(
            &self,
            source_filter: &UUri,
            sink_filter: Option<&UUri>,
            listener: Arc<dyn UListener>,
        ) -> Result<(), UStatus> {
            self.do_unregister_listener(source_filter, sink_filter, listener)
                .await
        }
    }

    mock! {
        pub(crate) RpcClientMock {}

        #[async_trait]
        impl RpcClient for RpcClientMock {
            async fn invoke_method(
                &self,
                method: UUri,
                call_options: CallOptions,
                payload: Option<UPayload>,
            ) -> Result<Option<UPayload>, ServiceInvocationError>;
        }

    }

    mock! {
        pub(crate) SubscriptionService {}

        impl USubscriptionServiceAbstract for SubscriptionService {}

        impl UTransportHolder for SubscriptionService {
            fn get_transport(&self) -> Arc<dyn UTransport>;
        }

        impl LocalUriProvider for SubscriptionService {
            fn get_authority(&self) -> String;
            fn get_resource_uri(&self, resource_id: u16) -> UUri;
            fn get_source_uri(&self) -> UUri;
        }

        #[async_trait]
        impl USubscription for SubscriptionService {
            async fn subscribe(
                &self,
                subscription_request: SubscriptionRequest,
            ) -> Result<SubscriptionResponse, UStatus>;
            async fn unsubscribe(&self, unsubscribe_request: UnsubscribeRequest) -> Result<(), UStatus>;
            async fn register_for_notifications(
                &self,
                notifications_register_request: NotificationsRequest,
            ) -> Result<(), UStatus>;
            async fn unregister_for_notifications(
                &self,
                notifications_unregister_request: NotificationsRequest,
            ) -> Result<(), UStatus>;
            async fn fetch_subscribers(
                &self,
                fetch_subscribers_request: FetchSubscribersRequest,
            ) -> Result<FetchSubscribersResponse, UStatus> ;
            async fn fetch_subscriptions(
                &self,
                fetch_subscriptions_request: FetchSubscriptionsRequest,
            ) -> Result<FetchSubscriptionsResponse, UStatus>;
        }
    }

    pub(crate) fn usubscription_default_mock(
        do_send_count: usize,
    ) -> Arc<dyn USubscriptionServiceAbstract> {
        let mut mock_transport = MockTransport::default();
        mock_transport
            .expect_do_send()
            .times(do_send_count)
            .return_const(Ok(()));

        let mock_client = MockRpcClientMock::default();
        let (urun, _) = USubscriptionService::run(
            USubscriptionConfiguration::create(
                test_lib::helpers::LOCAL_AUTHORITY.to_string(),
                None,
                None,
            )
            .unwrap(),
            Arc::new(mock_transport),
            Arc::new(mock_client),
        )
        .unwrap();

        urun
    }

    pub(crate) fn usubscription_mock_for_listener_tests(
        send_return: UMessage,
    ) -> MockSubscriptionService {
        // Build mock transport, that is used to send() final result from listener
        let mut mock_transport = MockTransport::default();
        mock_transport
            .expect_do_send()
            .withf(move |msg| test_lib::is_equivalent_umessage(msg, &send_return))
            .return_const(Ok(()));

        let arc_dyn_transport: Arc<dyn UTransport> = Arc::new(mock_transport);

        // Build usubscription mock, by first telling it to return above mock transport
        let mut mock_usubscription = MockSubscriptionService::default();
        mock_usubscription
            .expect_get_transport()
            .return_const(arc_dyn_transport);

        mock_usubscription
    }

    pub(crate) fn utransport_mock_for_notifications(
    ) -> (NotificationTransportMock, Receiver<NotificationTuple>) {
        let (sender, receiver) = mpsc::channel::<NotificationTuple>(1);
        let mock_transport: NotificationTransportMock = NotificationTransportMock::new(sender);
        (mock_transport, receiver)
    }

    pub(crate) fn utransport_mock_for_notification_manager(
        expected_messages: Vec<UMessage>,
    ) -> MockTransport {
        let mut mock_transport = MockTransport::default();

        for expected_message in expected_messages {
            mock_transport
                .expect_do_send()
                .once()
                .withf(move |message| test_lib::is_equivalent_umessage(message, &expected_message))
                .return_const(Ok(()));
        }

        mock_transport
    }
}

// Various methods for constructing helper objects to be used in tests
#[cfg(test)]
pub(crate) mod helpers {
    use up_rust::core::usubscription::{
        SubscriberInfo, SubscriptionRequest, UnsubscribeRequest, USUBSCRIPTION_TYPE_ID,
        USUBSCRIPTION_VERSION_MAJOR,
    };
    use up_rust::UUri;

    pub(crate) const LOCAL_AUTHORITY: &str = "LOCAL";
    pub(crate) const REMOTE_AUTHORITY: &str = "REMOTE";

    const SUBSCRIBER1_ID: u32 = 0x0000_1000;
    const SUBSCRIBER1_VERSION: u32 = 0x0000_0001;
    const SUBSCRIBER1_RESOURCE: u32 = 0x000_1000;

    const SUBSCRIBER2_ID: u32 = 0x0000_2000;
    const SUBSCRIBER2_VERSION: u32 = 0x0000_0001;
    const SUBSCRIBER2_RESOURCE: u32 = 0x0000_1000;

    const SUBSCRIBER3_ID: u32 = 0x0000_3000;
    const SUBSCRIBER3_VERSION: u32 = 0x0000_0001;
    const SUBSCRIBER3_RESOURCE: u32 = 0x0000_1000;

    const NOTIFICATION_TOPIC_ID: u32 = 0x001_0000;
    const NOTIFICATION_TOPIC_VERSION: u32 = 0x0000_0001;
    const NOTIFICATION_TOPIC_RESOURCE: u32 = 0x0000_8001;

    const TOPIC_LOCAL1_ID: u32 = 0x0010_0000;
    const TOPIC_LOCAL1_VERSION: u32 = 0x0000_0001;
    const TOPIC_LOCAL1_RESOURCE: u32 = 0x00A9_8AC7;

    const TOPIC_LOCAL2_ID: u32 = 0x0020_0000;
    const TOPIC_LOCAL2_VERSION: u32 = 0x0000_0001;
    const TOPIC_LOCAL2_RESOURCE: u32 = 0x0153_158E;

    const TOPIC_LOCAL3_ID: u32 = 0x0030_0000;
    const TOPIC_LOCAL3_VERSION: u32 = 0x0000_0001;
    const TOPIC_LOCAL3_RESOURCE: u32 = 0x01FC_A055;

    const TOPIC_REMOTE1_ID: u32 = 0x0000_5000;
    const TOPIC_REMOTE1_VERSION: u32 = 0x0000_0001;
    const TOPIC_REMOTE1_RESOURCE: u32 = 0x2000_0000;

    pub(crate) const UENTITY_OWN_URI: &str = "/7777/1/0";

    pub(crate) fn subscriber_info1() -> SubscriberInfo {
        SubscriberInfo {
            uri: Some(UUri {
                authority_name: LOCAL_AUTHORITY.into(),
                ue_id: SUBSCRIBER1_ID,
                ue_version_major: SUBSCRIBER1_VERSION,
                resource_id: SUBSCRIBER1_RESOURCE,
                ..Default::default()
            })
            .into(),
            ..Default::default()
        }
    }

    pub(crate) fn subscriber_info2() -> SubscriberInfo {
        SubscriberInfo {
            uri: Some(UUri {
                authority_name: LOCAL_AUTHORITY.into(),
                ue_id: SUBSCRIBER2_ID,
                ue_version_major: SUBSCRIBER2_VERSION,
                resource_id: SUBSCRIBER2_RESOURCE,
                ..Default::default()
            })
            .into(),
            ..Default::default()
        }
    }

    pub(crate) fn subscriber_info3() -> SubscriberInfo {
        SubscriberInfo {
            uri: Some(UUri {
                authority_name: LOCAL_AUTHORITY.into(),
                ue_id: SUBSCRIBER3_ID,
                ue_version_major: SUBSCRIBER3_VERSION,
                resource_id: SUBSCRIBER3_RESOURCE,
                ..Default::default()
            })
            .into(),
            ..Default::default()
        }
    }

    pub(crate) fn local_usubscription_service_uri() -> UUri {
        UUri {
            authority_name: LOCAL_AUTHORITY.into(),
            ue_id: USUBSCRIPTION_TYPE_ID,
            ue_version_major: USUBSCRIPTION_VERSION_MAJOR as u32,
            ..Default::default()
        }
    }

    pub(crate) fn notification_topic_uri() -> UUri {
        UUri {
            authority_name: LOCAL_AUTHORITY.into(),
            ue_id: NOTIFICATION_TOPIC_ID,
            ue_version_major: NOTIFICATION_TOPIC_VERSION,
            resource_id: NOTIFICATION_TOPIC_RESOURCE,
            ..Default::default()
        }
    }

    pub(crate) fn local_topic1_uri() -> UUri {
        UUri {
            authority_name: LOCAL_AUTHORITY.into(),
            ue_id: TOPIC_LOCAL1_ID,
            ue_version_major: TOPIC_LOCAL1_VERSION,
            resource_id: TOPIC_LOCAL1_RESOURCE,
            ..Default::default()
        }
    }

    pub(crate) fn local_topic2_uri() -> UUri {
        UUri {
            authority_name: LOCAL_AUTHORITY.into(),
            ue_id: TOPIC_LOCAL2_ID,
            ue_version_major: TOPIC_LOCAL2_VERSION,
            resource_id: TOPIC_LOCAL2_RESOURCE,
            ..Default::default()
        }
    }

    pub(crate) fn local_topic3_uri() -> UUri {
        UUri {
            authority_name: LOCAL_AUTHORITY.into(),
            ue_id: TOPIC_LOCAL3_ID,
            ue_version_major: TOPIC_LOCAL3_VERSION,
            resource_id: TOPIC_LOCAL3_RESOURCE,
            ..Default::default()
        }
    }

    pub(crate) fn remote_topic1_uri() -> UUri {
        UUri {
            authority_name: REMOTE_AUTHORITY.into(),
            ue_id: TOPIC_REMOTE1_ID,
            ue_version_major: TOPIC_REMOTE1_VERSION,
            resource_id: TOPIC_REMOTE1_RESOURCE,
            ..Default::default()
        }
    }

    pub(crate) fn subscription_request(
        topic: UUri,
        subscriber: SubscriberInfo,
    ) -> SubscriptionRequest {
        SubscriptionRequest {
            topic: Some(topic).into(),
            subscriber: Some(subscriber).into(),
            ..Default::default()
        }
    }

    pub(crate) fn unsubscribe_request(
        topic: UUri,
        subscriber: SubscriberInfo,
    ) -> UnsubscribeRequest {
        UnsubscribeRequest {
            topic: Some(topic).into(),
            subscriber: Some(subscriber).into(),
            ..Default::default()
        }
    }
}
